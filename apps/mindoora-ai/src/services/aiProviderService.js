import OpenAI from 'openai';
import { HfInference } from '@huggingface/inference';
import { GoogleGenerativeAI } from '@google/generative-ai';
import config from '../config/index.js';
import logger from '../utils/logger.js';
import cacheService from './cacheService.js';
import localModelService from './localModelService.js';
import workingModelService from './workingModelService.js';
import finalWorkingModelService from './finalWorkingModelService.js';
import t5QuestionService from './t5QuestionService.js';

class AIProviderService {
  constructor() {
    this.providers = {};
    this.initProviders();
  }

  initProviders() {
    // Initialize OpenAI
    if (config.openai.apiKey) {
      try {
        this.providers.openai = new OpenAI({
          apiKey: config.openai.apiKey,
        });
        logger.info('OpenAI provider initialized');
      } catch (error) {
        logger.error('Failed to initialize OpenAI provider:', error.message);
      }
    } else {
      logger.info('OpenAI provider not initialized - no API key provided');
    }

    // Initialize Hugging Face
    if (config.huggingface.apiKey) {
      try {
        this.providers.huggingface = new HfInference(config.huggingface.apiKey);
        logger.info('Hugging Face provider initialized');
      } catch (error) {
        logger.error('Failed to initialize Hugging Face provider:', error.message);
      }
    } else {
      logger.info('Hugging Face provider not initialized - no API key provided');
    }

    // Initialize Google AI
    if (config.googleAI.apiKey) {
      try {
        this.providers.googleai = new GoogleGenerativeAI(config.googleAI.apiKey);
        logger.info('Google AI provider initialized');
      } catch (error) {
        logger.error('Failed to initialize Google AI provider:', error.message);
      }
    } else {
      logger.info('Google AI provider not initialized - no API key provided');
    }

    // T5 service is always available if Hugging Face is initialized
    if (this.providers.huggingface) {
      logger.info('T5 question generation service available');
    }

    // Log available providers
    const availableProviders = this.getAvailableProviders();
    logger.info(`Available AI providers: ${availableProviders.join(', ')}`);
    
    if (availableProviders.length === 0) {
      logger.warn('No AI providers initialized! Only local model service will be available.');
    }
  }

  /**
   * Generate questions using the specified provider
   */
  async generateQuestions(prompt, options = {}) {
    const {
      provider = config.ai.defaultProvider,
      count = 5,
      difficulty = 'medium',
      questionTypes = ['multiple-choice'],
      useCache = true,
    } = options;

    // Generate cache key
    const cacheKey = cacheService.generateKey(
      'questions',
      provider,
      this.hashString(prompt),
      count,
      difficulty,
      questionTypes.join('-')
    );

    // Check cache first
    if (useCache) {
      const cachedResult = await cacheService.get(cacheKey);
      if (cachedResult) {
        logger.info('Questions retrieved from cache');
        return cachedResult;
      }
    }

    const startTime = Date.now();
    let result;

    try {
      switch (provider) {
        case 'openai':
          result = await this.generateWithOpenAI(prompt, { count, difficulty, questionTypes });
          break;
        case 'huggingface':
          result = await this.generateWithHuggingFace(prompt, { count, difficulty, questionTypes });
          break;
        case 'googleai':
          result = await this.generateWithGoogleAI(prompt, { count, difficulty, questionTypes });
          break;
        case 't5':
          result = await this.generateWithT5(prompt, { count, difficulty, questionTypes });
          break;
        case 'local':
          result = await this.generateWithLocal(prompt, { count, difficulty, questionTypes });
          break;
        default:
          throw new Error(`Unsupported AI provider: ${provider}`);
      }

      const duration = Date.now() - startTime;
      
      // Check if we actually got questions
      if (!result || !result.questions || result.questions.length === 0) {
        throw new Error(`No questions generated by ${provider}`);
      }
      
      logger.logAIRequest(provider, prompt, duration, true);

      // Cache the result
      if (useCache && result) {
        await cacheService.set(cacheKey, result);
      }

      return result;

    } catch (error) {
      const duration = Date.now() - startTime;
      logger.logAIRequest(provider, prompt, duration, false);
      logger.logError(error, { context: 'AI question generation failed', provider });

      // Try fallback providers in order
      const fallbackProviders = this.getAvailableFallbackProviders(provider);
      
      if (fallbackProviders.length > 0) {
        const nextProvider = fallbackProviders[0];
        logger.info(`Attempting fallback to ${nextProvider}`);
        return this.generateQuestions(prompt, { 
          ...options, 
          provider: nextProvider 
        });
      }

      // If all providers fail, try final working model service as final fallback
      logger.warn('All AI providers failed, trying final working model service');
      try {
        return await finalWorkingModelService.generateQuestions(prompt, {
          count,
          difficulty
        });
      } catch (localError) {
        logger.error('Final model service also failed:', localError.message);
        // Final fallback to mock questions
        return localModelService.generateFallbackQuestions(prompt, count, difficulty);
      }
    }
  }

  /**
   * Generate questions using OpenAI
   */
  async generateWithOpenAI(prompt, options) {
    if (!this.providers.openai) {
      throw new Error('OpenAI provider not initialized');
    }

    const { count, difficulty, questionTypes } = options;
    
    const systemPrompt = this.buildSystemPrompt(count, difficulty, questionTypes);
    const userPrompt = `Topic: ${prompt}`;

    const response = await this.providers.openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      temperature: 0.7,
      max_tokens: 2000,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content received from OpenAI');
    }

    return this.parseQuestionsFromResponse(content);
  }

  /**
   * Generate questions using Hugging Face
   */
  async generateWithHuggingFace(prompt, options) {
    if (!this.providers.huggingface) {
      throw new Error('Hugging Face provider not initialized');
    }

    const { count, difficulty, questionTypes } = options;
    
    const systemPrompt = this.buildSystemPrompt(count, difficulty, questionTypes);
    const fullPrompt = `${systemPrompt}\n\nTopic: ${prompt}`;

    const response = await this.providers.huggingface.textGeneration({
      model: 'microsoft/DialoGPT-large',
      inputs: fullPrompt,
      parameters: {
        max_new_tokens: 1000,
        temperature: 0.7,
        return_full_text: false,
      },
    });

    const content = response.generated_text;
    if (!content) {
      throw new Error('No content received from Hugging Face');
    }

    return this.parseQuestionsFromResponse(content);
  }

  /**
   * Generate questions using Google AI
   */
  async generateWithGoogleAI(prompt, options) {
    if (!this.providers.googleai) {
      throw new Error('Google AI provider not initialized');
    }

    const { count, difficulty, questionTypes } = options;
    
    const model = this.providers.googleai.getGenerativeModel({ model: 'gemini-1.5-flash' });
    
    const systemPrompt = this.buildSystemPrompt(count, difficulty, questionTypes);
    const fullPrompt = `${systemPrompt}\n\nTopic: ${prompt}`;

    const result = await model.generateContent(fullPrompt);
    const response = await result.response;
    const content = response.text();

    if (!content) {
      throw new Error('No content received from Google AI');
    }

    return this.parseQuestionsFromResponse(content);
  }

  /**
   * Generate questions using final working model service
   */
  async generateWithLocal(prompt, options) {
    const { count, difficulty, questionTypes } = options;
    
    try {
      // Use the final working model service that generates truly realistic questions
      const result = await finalWorkingModelService.generateQuestions(prompt, {
        count,
        difficulty
      });
      
      // The final service always returns high-quality questions
      if (!result || !result.questions || result.questions.length === 0) {
        logger.warn('Final model service generated no questions, using original fallback');
        return localModelService.generateFallbackQuestions(prompt, count, difficulty);
      }
      
      return result;
    } catch (error) {
      logger.error('Final model service failed, using fallback questions:', error.message);
      return localModelService.generateFallbackQuestions(prompt, count, difficulty);
    }
  }

  /**
   * Generate questions using T5 fine-tuned model
   */
  async generateWithT5(prompt, options) {
    const { count, difficulty, questionTypes } = options;
    
    try {
      // Map question types to T5-compatible format
      const questionType = questionTypes.includes('multiple-choice') ? 'multiple choice question' : 
                          questionTypes.includes('true-false') ? 'true false question' : 
                          'multiple choice question';
      
      const result = await t5QuestionService.generateQuestions(prompt, {
        count,
        difficulty,
        questionType,
        useCache: true
      });
      
      // Check if T5 actually generated questions
      if (!result || !result.questions || result.questions.length === 0) {
        logger.warn('T5 model generated no questions, using fallback');
        return t5QuestionService.generateFallbackQuestions(prompt, count, difficulty);
      }
      
      return result;
    } catch (error) {
      logger.error('T5 model failed, using fallback questions:', error.message);
      return t5QuestionService.generateFallbackQuestions(prompt, count, difficulty);
    }
  }

  /**
   * Build system prompt for question generation
   */
  buildSystemPrompt(count, difficulty, questionTypes) {
    return `You are an expert quizmaster, known for creating authentic and engaging questions. Generate ${count} ${difficulty} difficulty quiz questions on the given topic.

Requirements:
- Question types: ${questionTypes.join(', ')}
- Each question must have 4 answer options (A, B, C, D), with only one correct answer.
- Distractors (incorrect options) must be plausible and relevant to the topic.
- Avoid overly academic or formulaic language. Use a natural, conversational tone.
- Where appropriate, use real-world scenarios or case studies to frame the questions.

Response format (valid JSON only):
{
  "questions": [
    {
      "id": 1,
      "topic": "Relevant topic/category",
      "difficulty": "${difficulty}",
      "context": "Optional: Provide a brief scenario or background for the question.",
      "question": "Your engaging and realistic question text here?",
      "options": {
        "A": "Plausible option A",
        "B": "Correct option B",
        "C": "Plausible option C",
        "D": "Plausible option D"
      },
      "correctAnswer": "B",
      "explanation": "A clear and concise explanation of why the correct answer is right."
    }
  ]
}`;
  }

  /**
   * Parse questions from AI response
   */
  parseQuestionsFromResponse(content) {
    try {
      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No JSON found in response');
      }

      const parsed = JSON.parse(jsonMatch[0]);
      
      if (!parsed.questions || !Array.isArray(parsed.questions)) {
        throw new Error('Invalid response format: missing questions array');
      }

      // Validate each question
      const validatedQuestions = parsed.questions.map((q, index) => {
        if (!q.question || !q.options || !q.correctAnswer) {
          throw new Error(`Invalid question format at index ${index}`);
        }

        return {
          id: q.id || index + 1,
          question: q.question.trim(),
          options: q.options,
          correctAnswer: q.correctAnswer,
          explanation: q.explanation || '',
          difficulty: q.difficulty || 'medium',
          topic: q.topic || 'General',
          context: q.context || null,
        };
      });

      return {
        questions: validatedQuestions,
        metadata: {
          generated_at: new Date().toISOString(),
          count: validatedQuestions.length,
          provider: 'ai',
        },
      };

    } catch (error) {
      logger.logError(error, { context: 'Failed to parse AI response', content });
      throw new Error('Failed to parse questions from AI response');
    }
  }

  /**
   * Analyze content difficulty
   */
  async analyzeContent(text, provider = config.ai.defaultProvider) {
    const cacheKey = cacheService.generateKey('analysis', provider, this.hashString(text));
    
    // Check cache first
    const cachedResult = await cacheService.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }

    const prompt = `Analyze the following text and provide:
1. Reading difficulty level (beginner, intermediate, advanced)
2. Key topics and concepts
3. Suggested question types for this content

Text: ${text}

Respond in JSON format:
{
  "difficulty": "intermediate",
  "topics": ["topic1", "topic2"],
  "suggestedQuestionTypes": ["multiple-choice", "true-false"],
  "keyPoints": ["point1", "point2"]
}`;

    try {
      const result = await this.generateQuestions(prompt, { 
        provider, 
        count: 1,
        useCache: false 
      });
      
      await cacheService.set(cacheKey, result);
      return result;
    } catch (error) {
      logger.logError(error, { context: 'Content analysis failed' });
      throw error;
    }
  }

  /**
   * Simple hash function for cache keys
   */
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(36);
  }

  /**
   * Get available providers in order of preference (excluding the current provider)
   */
  getAvailableFallbackProviders(currentProvider) {
    // Define provider priority order based on reliability and availability
    const providerPriority = ['local', 't5', 'huggingface', 'googleai', 'openai'];
    
    return providerPriority.filter(provider => {
      // Exclude the current provider that failed
      if (provider === currentProvider) {
        return false;
      }
      
      // Check if the provider is available
      if (provider === 't5') {
        return !!config.huggingface.apiKey; // T5 uses Hugging Face API
      }
      
      if (provider === 'huggingface') {
        return !!this.providers.huggingface;
      }
      
      if (provider === 'googleai') {
        return !!this.providers.googleai;
      }
      
      if (provider === 'openai') {
        return !!this.providers.openai;
      }
      
      return false;
    });
  }

  /**
   * Get available providers
   */
  getAvailableProviders() {
    const standardProviders = Object.keys(this.providers);
    
    // Add T5 if Hugging Face API key is available
    if (config.huggingface.apiKey) {
      standardProviders.push('t5');
    }
    
    // Local service is always available
    standardProviders.push('local');
    
    return standardProviders;
  }

  /**
   * Health check for providers
   */
  async healthCheck() {
    const results = {};
    
    // Check standard providers
    for (const [name, provider] of Object.entries(this.providers)) {
      try {
        // Simple test request
        await this.generateQuestions('Test topic', { 
          provider: name, 
          count: 1, 
          useCache: false 
        });
        results[name] = { status: 'healthy' };
      } catch (error) {
        results[name] = { status: 'error', message: error.message };
      }
    }
    
    // Check T5 service separately
    try {
      const t5Health = await t5QuestionService.healthCheck();
      results['t5'] = t5Health;
    } catch (error) {
      results['t5'] = { status: 'error', message: error.message };
    }

    return results;
  }
}

export default new AIProviderService();
